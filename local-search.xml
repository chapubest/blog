<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>AJAX</title>
    <link href="/blog/post/uncategorized/f3334fd0/"/>
    <url>/blog/post/uncategorized/f3334fd0/</url>
    
    <content type="html"><![CDATA[<p><code>ajax</code>是一种异步请求方法，可以实现网页异步更新。  </p><blockquote><p>英文 Asynchronous JavaScript and XML  </p></blockquote><h3 id="原生js"><a href="#原生js" class="headerlink" title="原生js"></a>原生js</h3><pre><code class="hljs js"><span class="hljs-keyword">var</span> xhr;<span class="hljs-comment">// 实例化xhr对象</span><span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.XMLHttpRequest) &#123;    xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();&#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">// 浏览器不支持XMLHttpRequest</span>    xhr = <span class="hljs-keyword">new</span> ActiveXObject(<span class="hljs-string">&quot;Microsoft.XMLHTTP&quot;</span>);&#125;<span class="hljs-comment">// 设置响应方法</span>xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">if</span> (xhr.readyState === <span class="hljs-number">4</span> &amp;&amp; xhr.status === <span class="hljs-number">200</span>) &#123;        <span class="hljs-comment">// 从xhr.responseText | xhr.responseXML中获取响应内容</span>    &#125;&#125;<span class="hljs-comment">// 规定请求类型 POST | GET</span><span class="hljs-comment">// 最后一个参数表示是否异步处理 ajax必须设置true</span>xhr.open(method, url, <span class="hljs-literal">true</span>);<span class="hljs-comment">// 你还可以设置请求头</span>xhr.setRequestHeader(header, value);<span class="hljs-comment">// 发送请求 post请求可以传入string参数</span>xhr.send(data);</code></pre><p>如果你在<code>send</code>函数中是否异步传入<code>false</code>，请不要编写<code>onreadystatechange</code>函数，你只要将响应处理代码放到<code>send</code>函数后即可。  </p><h3 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h3><h4 id="ajax"><a href="#ajax" class="headerlink" title="ajax"></a>ajax</h4><p><code>jquery</code>主要使用<code>ajax</code>方法来进行ajax请求。  </p><pre><code class="hljs js"><span class="hljs-comment">// 传入一个对象用来配置ajax请求</span>$.ajax(&#123;    key: value,    ...&#125;);</code></pre><p>下面展示一些常用配置项<br><code>url</code><br>请求的地址，默认是当前页地址。<br><code>type</code><br>请求方式，默认是<code>&quot;GET&quot;</code>。<br><code>async</code><br>是否异步请求，默认是<code>true</code>。<br><code>error</code><br>请求失败时调用该函数，包括三个参数：xhr对象、错误信息、捕获的异常。<br><code>success</code><br>请求成功时调用该函数，包括两个参数：服务器返回后根据<code>dataType</code>处理后的数据、描述状态的字符串。<br><code>dataType</code><br>指定预期返回的数据类型，默认根据<code>http</code>的<code>MIME</code>头自动判断。<br><code>data</code><br>发送的数据，自动转换为请求字符串格式。必须为key/value格式的字符串。<br><code>contentType</code><br>发送到服务器的内容编码类型，默认是<code>&quot;application/x-www-form-urlencoded&quot;</code>。<br><code>timeout</code><br>请求超时时间毫秒，默认是全局设置。<br><code>beforeSend</code><br>在请求发送之前调用该函数，包括一个参数：xhr对象，可以返回<code>false</code>取消本次请求。<br><code>complete</code><br>在请求完成之后调用该函数，包括两个参数：xhr对象，描述请求类型的字符串。  </p><p>以上所有配置项均可以通过<code>ajaxSetup</code>方法进行全局设置。  </p><h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><p>你可以通过<code>jquery</code>的<code>get</code>方法进行简单的GET请求。  </p><pre><code class="hljs js">$.get(url, data, success, dataType);</code></pre><p>其中<code>url</code>是必传的，其他参数可以参考<code>ajax</code>方法的配置项。<br><code>success</code>是请求成功时执行的函数，包括三个参数：response请求结果数据、请求状态、xhr对象。  </p><h4 id="getJSON"><a href="#getJSON" class="headerlink" title="getJSON"></a>getJSON</h4><p>你可以通过<code>jquery</code>的<code>getJSON</code>方法进行简单的GET请求JSON数据。  </p><pre><code class="hljs js">$.getJSON(url, data, success);</code></pre><p>其中<code>url</code>是必传的，其他参数可以参考<code>ajax</code>方法的配置项。<br><code>success</code>是请求成功时执行的函数，包括三个参数：response请求结果数据、请求状态、xhr对象。  </p><h4 id="getScript"><a href="#getScript" class="headerlink" title="getScript"></a>getScript</h4><p>你可以通过<code>jquery</code>的<code>getScript</code>方法进行简单的GET请求并允许一个JavaScript文件。  </p><pre><code class="hljs js">$.getScript(url, success);</code></pre><p>其中<code>url</code>是必传的。<br><code>success</code>是请求成功时执行的函数，包括两个参数：response请求结果数据、请求状态。  </p><h4 id="post"><a href="#post" class="headerlink" title="post"></a>post</h4><p>你可以通过<code>jquery</code>的<code>post</code>方法进行简单的POST请求。  </p><pre><code class="hljs js">$.post(url, data, success, dataType);</code></pre><p>其中<code>url</code>是必传的，其他参数可以参考<code>ajax</code>方法的配置项。<br><code>success</code>是请求成功时执行的函数，包括三个参数：response请求结果数据、请求状态、xhr对象。  </p><h3 id="关于JSONP"><a href="#关于JSONP" class="headerlink" title="关于JSONP"></a>关于JSONP</h3><p>这里补充一些关于JSONP的知识。  </p><h4 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h4><p>归功于Netscape，出于安全角度出发浏览器有一个同源策略。所以通过ajax直接进行请求是有跨域限制问题的。<br>然而web上调用js文件是不受跨域限制的，实际上用于<code>src</code>属性的标签都拥有跨域的能力。<br>因此我们可以通过调用跨域服务器上动态生成的js文件（通常以JSON为后缀），获取需要的JSON数据。<br>这种调用方式看起来与ajax类似，但其实是不一样的。ajax核心是通过xhr对象获取内容，而jsonp核心是动态添加js。<br>这种方式后来形成了一种非正式协议，被称为JSONP。</p><blockquote><p>英文为 json and padding  </p></blockquote><p>该协议的主要原理就是，允许用户传递一个callback给服务器，服务器会根据callback作为函数名包裹实际的JSON数据，然后就可以随意处理返回数据了。  </p><h4 id="jQuery使用JSONP例子"><a href="#jQuery使用JSONP例子" class="headerlink" title="jQuery使用JSONP例子"></a>jQuery使用JSONP例子</h4><pre><code class="hljs js">$.ajax(&#123;    url: <span class="hljs-string">&quot;http://localhost&quot;</span>,    type: <span class="hljs-string">&quot;GET&quot;</span>,    dataType: <span class="hljs-string">&quot;jsonp&quot;</span>,    <span class="hljs-comment">// 重写回调函数参数名称，默认为callback</span>    jsonp: <span class="hljs-string">&quot;callback&quot;</span>,    <span class="hljs-comment">// 指定一个回调函数名称，默认为jQuery自动生成随机名称</span>    jsonpCallback: <span class="hljs-string">&quot;showjson&quot;</span>,    <span class="hljs-comment">// 上面两条设置会将&quot;callback=showjson&quot;附加在请求url后</span>    success: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(data);    &#125;,    error: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">xhr, textStatus</span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(textStatus);    &#125;&#125;)</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>ajax</tag>
      
      <tag>jquery</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js基础之Array</title>
    <link href="/blog/post/uncategorized/5e8f0129/"/>
    <url>/blog/post/uncategorized/5e8f0129/</url>
    
    <content type="html"><![CDATA[<p><code>Array</code>是js中的原生对象，它有许多方法，下面简单的对他们进行一个总结：  </p><h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h3><p><code>Array</code>实例对象拥有的方法，可以进行重写。  </p><table><thead><tr><th>方法名</th><th>作用</th><th>是否影响原数组</th><th>返回值</th><th>备注</th><th>例子</th></tr></thead><tbody><tr><td><code>push</code></td><td>在数组末端添加一个或多个元素</td><td>是</td><td>添加新元素后的数组长度</td><td>可以同时传入多个参数，会被依次添加到数组中</td><td></td></tr><tr><td><code>pop</code></td><td>删除数组中的最后一个元素</td><td>是</td><td>删除的元素</td><td></td><td></td></tr><tr><td><code>shift</code></td><td>删除数组的第一个元素</td><td>是</td><td>删除的元素</td><td></td><td></td></tr><tr><td><code>unshift</code></td><td>在数组头部添加元素</td><td>是</td><td>添加新元素后的数组长度</td><td></td><td></td></tr><tr><td><code>join</code></td><td>以指定参数作为分隔符，将数组元素连接成一个字符串</td><td>否</td><td>连接成的字符串</td><td>不传参数默认用逗号分隔</td><td></td></tr><tr><td><code>concat</code></td><td>将数组合并到原数组后面</td><td>否</td><td>合并后的新数组</td><td>可以同时传入多个参数，会被依次添加到数组中  参数可以是其他类型  不传参数返回原数组的浅拷贝</td><td></td></tr><tr><td><code>reverse</code></td><td>将数组元素倒序排列</td><td>是</td><td>改变后的数组</td><td></td><td></td></tr><tr><td><code>slice</code></td><td>提取数组中的部分元素</td><td>否</td><td>提取的元素数组</td><td>参数start和end，可以为负，提取的元素是包含start不包含end的  不传参数返回原数组的拷贝</td><td></td></tr><tr><td><code>splice</code></td><td>删除数组的一部分元素，并从删除位置添加新的元素</td><td>是</td><td>被删除的元素数组</td><td>第一个参数表示删除的起始位置  第二个参数表示被删除的元素个数  之后的参数表示要插入的新元素</td><td></td></tr><tr><td><code>sort</code></td><td>对数组元素进行排序</td><td>是</td><td>排序后的数组</td><td>默认按照字典顺序排序  可传函数定义排序方式</td><td><a href="#demo_sort">例子</a></td></tr><tr><td><code>map</code></td><td>将数组的所有元素依次传入参数函数将调用结果组成新数组</td><td>否</td><td>映射后的新数组</td><td>传入函数包括三个参数依次为：当前元素，当前位置，数组本身</td><td><a href="#demo_map">例子</a></td></tr><tr><td><code>forEach</code></td><td>与<code>map</code>类似，将数组的所有元素依次传入参数函数</td><td>由传入函数逻辑决定</td><td>无</td><td>传入函数包括三个参数依次为：当前元素，当前位置，数组本身</td><td><a href="#demo_forEach">例子</a></td></tr><tr><td><code>filter</code></td><td>过滤数组元素</td><td>否</td><td>过滤后的新数组</td><td>过滤条件由传入函数决定  传入函数包括三个参数依次为：当前元素，当前位置，数组本身  传入函数返回true则保留对应元素</td><td><a href="#demo_filter">例子</a></td></tr><tr><td><code>some</code></td><td>类似断言，判断是否<strong>存在</strong>数组元素符合某条件</td><td>否</td><td>存在一个元素符合条件就返回true，反之返回false</td><td></td><td><a href="#demo_some">例子</a></td></tr><tr><td><code>every</code></td><td>类似断言，判断是否<strong>全部</strong>数组元素符合某条件</td><td>否</td><td>所有元素符合条件就返回true，反之返回false</td><td></td><td><a href="#demo_every">例子</a></td></tr><tr><td><code>reduce</code></td><td>从左到右依次处理数组元素，并累计一个值</td><td>否</td><td>最终返回结果</td><td>传入函数包括四个参数依次为：  累计变量（第一个元素)  当前变量（第二个元素）  当前位置  数组本身</td><td><a href="#demo_reduce">例子</a></td></tr><tr><td><code>reduceRight</code></td><td>与<code>reduce</code>类似，从右到左依次处理数组元素，并累计一个值</td><td>否</td><td>最终返回结果</td><td>传入函数包括四个参数依次为：  累计变量（最后一个元素)  当前变量（倒数第二个元素）  当前位置  数组本身</td><td></td></tr></tbody></table><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><h5 id="sort"><a href="#sort" class="headerlink" title="sort"></a><span id="demo_sort"><code>sort</code></span></h5><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>];arr.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);<span class="hljs-comment">// 返回 [0, 1, 2, 2, 4, 6, 6, 6]</span></code></pre><h5 id="map"><a href="#map" class="headerlink" title="map"></a><span id="demo_map"><code>map</code></span></h5><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];arr.map(<span class="hljs-function">(<span class="hljs-params">elem, index, arr</span>) =&gt;</span> &#123;  <span class="hljs-keyword">return</span> elem * index;&#125;);<span class="hljs-comment">// 返回 [0, 2, 6]</span></code></pre><h5 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a><span id="demo_forEach"><code>forEach</code></span></h5><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];arr.forEach(<span class="hljs-function">(<span class="hljs-params">elem, index, arr</span>) =&gt;</span> &#123;  <span class="hljs-built_in">console</span>.log(elem, index);&#125;);<span class="hljs-comment">// 返回 1 0</span><span class="hljs-comment">//      2 1</span><span class="hljs-comment">//      3 2</span></code></pre><h5 id="filter"><a href="#filter" class="headerlink" title="filter"></a><span id="demo_filter"><code>filter</code></span></h5><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];arr.filter(<span class="hljs-function">(<span class="hljs-params">elem</span>) =&gt;</span> &#123;  <span class="hljs-keyword">return</span> (elem &gt; <span class="hljs-number">3</span>);&#125;);<span class="hljs-comment">// 返回 [4, 5]</span></code></pre><h5 id="some"><a href="#some" class="headerlink" title="some"></a><span id="demo_some"><code>some</code></span></h5><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];arr.some(<span class="hljs-function">(<span class="hljs-params">elem</span>) =&gt;</span> &#123;  <span class="hljs-keyword">return</span> (elem &gt; <span class="hljs-number">3</span>);&#125;);<span class="hljs-comment">// 返回 true</span></code></pre><h5 id="every"><a href="#every" class="headerlink" title="every"></a><span id="demo_every"><code>every</code></span></h5><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];arr.every(<span class="hljs-function">(<span class="hljs-params">elem</span>) =&gt;</span> &#123;  <span class="hljs-keyword">return</span> (elem &gt; <span class="hljs-number">3</span>);&#125;);<span class="hljs-comment">// 返回 false</span></code></pre><h5 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a><span id="demo_reduce"><code>reduce</code></span></h5><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>];<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">subtract</span>(<span class="hljs-params">prev, cur</span>) </span>&#123;  <span class="hljs-keyword">return</span> prev - cur;&#125;arr.reduce(subtract)<span class="hljs-comment">// 返回 0</span>arr.reduceRight(subtract)<span class="hljs-comment">// 返回 -4</span></code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js中与数字有关的全局方法</title>
    <link href="/blog/post/uncategorized/503c2907/"/>
    <url>/blog/post/uncategorized/503c2907/</url>
    
    <content type="html"><![CDATA[<h3 id="parseInt"><a href="#parseInt" class="headerlink" title="parseInt"></a><code>parseInt</code></h3><p><code>parseInt</code>一般用于将字符串转换为整数，例如：  </p><pre><code class="hljs js"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;1290&quot;</span>) <span class="hljs-comment">// 1290</span></code></pre><p><code>parseInt</code>可以忽略前面的空格，从左到右进行依次转换，当识别到无法转换的字符，就返回已经转换完成的部分。<br><code>parseInt</code>默认转换为十进制数，你可以传入第二个参数（2-36），表示被解析的值的进制，例如：  </p><pre><code class="hljs js"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;10&quot;</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// 2</span><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;10&quot;</span>, <span class="hljs-number">8</span>) <span class="hljs-comment">// 8</span><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;10&quot;</span>, <span class="hljs-number">16</span>) <span class="hljs-comment">// 16</span></code></pre><h3 id="parseFloat"><a href="#parseFloat" class="headerlink" title="parseFloat"></a><code>parseFloat</code></h3><p><code>parseFloat</code>将字符串转换为浮点数。如果字符串符合科学计算，也可以进行相应转换，例如：  </p><pre><code class="hljs js"><span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&quot;3.11e-2&quot;</span>) <span class="hljs-comment">// 0.0311</span></code></pre><h3 id="isNaN"><a href="#isNaN" class="headerlink" title="isNaN"></a><code>isNaN</code></h3><p>可用来判断一个值是否为NaN。对于非数值，会先使用Number函数进行转换，例如：  </p><pre><code class="hljs js"><span class="hljs-built_in">isNaN</span>(<span class="hljs-string">&quot;Hello&quot;</span>) <span class="hljs-comment">// true</span></code></pre><h3 id="isFinity"><a href="#isFinity" class="headerlink" title="isFinity"></a><code>isFinity</code></h3><p><code>isFinity</code>用来判断一个值是否为正常值。  </p><pre><code class="hljs js"><span class="hljs-built_in">isFinite</span>(<span class="hljs-literal">Infinity</span>) <span class="hljs-comment">// false</span><span class="hljs-built_in">isFinite</span>(-<span class="hljs-literal">Infinity</span>) <span class="hljs-comment">// false</span><span class="hljs-built_in">isFinite</span>(<span class="hljs-literal">NaN</span>) <span class="hljs-comment">// false</span><span class="hljs-built_in">isFinite</span>(<span class="hljs-literal">undefined</span>) <span class="hljs-comment">// false</span><span class="hljs-built_in">isFinite</span>(<span class="hljs-literal">null</span>) <span class="hljs-comment">// true</span><span class="hljs-built_in">isFinite</span>(-<span class="hljs-number">1</span>) <span class="hljs-comment">// true</span></code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于1像素边框问题</title>
    <link href="/blog/post/uncategorized/c9ceacc1/"/>
    <url>/blog/post/uncategorized/c9ceacc1/</url>
    
    <content type="html"><![CDATA[<p>对于前端开发中经常遇到的1像素边框问题，一直以来我都是直接使用别人的css直接解决，对其中的知识一知半解。今天针对其中的各方面知识进行补学。<br>1px边框问题表现为移动端边框变粗了,为什么会这样呢?<br>因为实际上css描述的1px的像素是指逻辑像素，而ui要求的1px是指物理像素。<br>在以前这两个像素是1=1的关系，但是随着屏幕的发展，不同的设备这二者比例不再相等了。</p><blockquote><p>你可以通过js中的<code>window.devicsPixelRatio</code>或者通过媒体查询的<code>-webkit-min-device-pixel-ratio</code>来获取逻辑像素和物理像素的比例关系。  </p></blockquote><p>例如在iPhone8上，这个值是2。那么当你将border-width设为1px时，即逻辑像素设为1px，border被放大到物理像素2px显示，因此你会在iPhone感觉边框变粗了。  </p><p>你或许经常会看到在移动端web开发时，会在header里加上下面这段内容:  </p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no&quot;</span>&gt;</span></code></pre><p>这里其实约定了本页面viewport的宽度为设备宽度，初始缩放和最大最小缩放都为1，并且禁用用户缩放。<br>viewport，也就是视口，说白了就是屏幕上显示网页内容的区域，再具体一点就是指浏览器或者app中显示网页的那部分区域。这里的<code>user-scalable=no</code>设置用户禁止缩放，如果允许用户缩放，在显示上，缩放一倍，css（逻辑像素）所对应的物理像素也会缩放一倍。<br>至此，对1px问题发生的原因已经有了一个了解了：viewport的设置和屏幕物理分辨率是按比例而不是相同，window有个<code>devicsPixelRatio</code>用来描述设备物理像素和css逻辑像素的比例。在iPhone8上这个值为2，因此1px的边框在实际显示时隐射到的2px的物理像素。  </p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><h4 id="利用媒体查询，设置小数像素"><a href="#利用媒体查询，设置小数像素" class="headerlink" title="利用媒体查询，设置小数像素"></a>利用媒体查询，设置小数像素</h4><p>浏览器如果支持带小数的px值，可以通过媒体查询<code>-webkit-min-device-pixel-ratio</code>，针对<code>devicePixelRatio</code>设置border:  </p><pre><code class="hljs css"><span class="hljs-selector-class">.border</span> &#123; <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#999</span> &#125;<span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">-webkit-min-device-pixel-ratio:</span> <span class="hljs-number">2</span>) &#123;    <span class="hljs-selector-class">.border</span> &#123; <span class="hljs-attribute">border</span>: <span class="hljs-number">0.5px</span> solid <span class="hljs-number">#999</span> &#125;&#125;<span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">-webkit-min-device-pixel-ratio:</span> <span class="hljs-number">3</span>) &#123;    <span class="hljs-selector-class">.border</span> &#123; <span class="hljs-attribute">border</span>: <span class="hljs-number">0.333333px</span> solid <span class="hljs-number">#999</span> &#125;&#125;</code></pre><h3 id="设置viewport"><a href="#设置viewport" class="headerlink" title="设置viewport"></a>设置viewport</h3><p>如果不兼容小数像素，你也可以通过view+rem的方法  </p><pre><code class="hljs js"><span class="hljs-keyword">var</span> viewport = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;meta[name=viewport]&quot;</span>)<span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.devicePixelRatio == <span class="hljs-number">1</span>) &#123;    viewport.setAttribute(<span class="hljs-string">&#x27;content&#x27;</span>, <span class="hljs-string">&#x27;width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no&#x27;</span>)&#125; <span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.devicePixelRatio == <span class="hljs-number">2</span>) &#123;    viewport.setAttribute(<span class="hljs-string">&#x27;content&#x27;</span>, <span class="hljs-string">&#x27;width=device-width, initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no&#x27;</span>)&#125; <span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.devicePixelRatio == <span class="hljs-number">3</span>) &#123;    viewport.setAttribute(<span class="hljs-string">&#x27;content&#x27;</span>, <span class="hljs-string">&#x27;width=device-width, initial-scale=0.333333333, maximum-scale=0.333333333, minimum-scale=0.333333333, user-scalable=no&#x27;</span>)&#125; <span class="hljs-keyword">var</span> docEl = <span class="hljs-built_in">document</span>.documentElement;<span class="hljs-keyword">var</span> fontsize = <span class="hljs-number">10</span> * (docEl.clientWidth / <span class="hljs-number">375</span>) + <span class="hljs-string">&#x27;px&#x27;</span>;docEl.style.fontSize = fontsize;</code></pre><h4 id="通过transform"><a href="#通过transform" class="headerlink" title="通过transform"></a>通过transform</h4><p>你也可以通过transform对表示标识边框的元素进行缩放，实现需求  </p><pre><code class="hljs css"><span class="hljs-comment">/* 2倍屏 */</span><span class="hljs-keyword">@media</span> <span class="hljs-keyword">only</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">-webkit-min-device-pixel-ratio:</span> <span class="hljs-number">2.0</span>) &#123;    <span class="hljs-selector-class">.border-bottom</span><span class="hljs-selector-pseudo">::after</span> &#123;        <span class="hljs-attribute">-webkit-transform</span>: <span class="hljs-built_in">scaleY</span>(<span class="hljs-number">0.5</span>);        <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scaleY</span>(<span class="hljs-number">0.5</span>);    &#125;&#125;<span class="hljs-comment">/* 3倍屏 */</span><span class="hljs-keyword">@media</span> <span class="hljs-keyword">only</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">-webkit-min-device-pixel-ratio:</span> <span class="hljs-number">3.0</span>) &#123;    <span class="hljs-selector-class">.border-bottom</span><span class="hljs-selector-pseudo">::after</span> &#123;        <span class="hljs-attribute">-webkit-transform</span>: <span class="hljs-built_in">scaleY</span>(<span class="hljs-number">0.33</span>);        <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scaleY</span>(<span class="hljs-number">0.33</span>);    &#125;&#125;</code></pre><p>还有其他的方法，可以根据自己的实际需求进行使用，适合自己的才是最好的。  </p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://www.jianshu.com/p/fa670b737a29">https://www.jianshu.com/p/fa670b737a29</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>css</tag>
      
      <tag>viewport</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js视差动效</title>
    <link href="/blog/post/uncategorized/3997e63a/"/>
    <url>/blog/post/uncategorized/3997e63a/</url>
    
    <content type="html"><![CDATA[<p>如果你经常玩游戏的话，就会注意到游戏中的背景经常会用到一种视差效果，这会让游戏背景显得更富有层次感。这就叫视差滚动（parallax scrolling），指让多层背景以不同的速度移动，形成立体的效果，丰富视觉体验，在网页设计中也经常会使用。  </p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://www.wodecun.com/blog/8039.html">https://www.wodecun.com/blog/8039.html</a>  </li><li><a href="https://github.com/wagerfield/parallax">parallax.js github页</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>ui</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>简单上手npm</title>
    <link href="/blog/post/uncategorized/782520f3/"/>
    <url>/blog/post/uncategorized/782520f3/</url>
    
    <content type="html"><![CDATA[<p>❀持续更新❀</p><p>npm 是node的标准包管理工具。<br>node项目开发往往会使用npm来管理依赖，当然你也可以使用其他工具，例如<a href="">yarn</a>。  </p><p>初始化一个node项目：</p><pre><code class="hljs bash"><span class="hljs-comment"># 生成一个package.json文件</span>npm init</code></pre><p>安装包常用命令：  </p><pre><code class="hljs bash"><span class="hljs-comment"># 安装项目中的包</span>npm install<span class="hljs-comment"># 在生产环境下</span>npm install --production<span class="hljs-comment"># 安装包，该操作会将包安装到当前文件夹中的node_modules文件中，保存到生产环境（dependencies）</span>npm install &lt;包名&gt;<span class="hljs-comment"># 效果同上</span>npm install &lt;包名&gt; --save<span class="hljs-comment"># 安装包，同时保存到开发环境（devDependencies）</span>npm install &lt;包名&gt; --save-dev<span class="hljs-comment"># 效果同上</span>npm install &lt;包名&gt; -D<span class="hljs-comment"># 安装包的对应版本 x.x.x</span>npm install &lt;包名@版本号&gt;<span class="hljs-comment"># 全局安装包</span>npm install -g &lt;包名&gt;<span class="hljs-comment"># 效果同上</span>npm install --global &lt;包名&gt;<span class="hljs-comment"># 获取全局安装的路径</span>npm root -g</code></pre><p>删除包的大部分操作与安装类似，只需要将<code>install</code>变成<code>uninstall</code>：  </p><pre><code class="hljs bash"><span class="hljs-comment"># 删除当前项目文件所有依赖</span><span class="hljs-comment"># 可用性存疑</span>npm uninstall *</code></pre><p>你可以在package.json文件中指定一些任务，通过以下方式运行：  </p><pre><code class="hljs bash">npm run &lt;任务名&gt;</code></pre><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://nodejs.cn/api/">node官方文档</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>nodejs</tag>
      
      <tag>npm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mongoDB中的BSON</title>
    <link href="/blog/post/uncategorized/b6830d96/"/>
    <url>/blog/post/uncategorized/b6830d96/</url>
    
    <content type="html"><![CDATA[<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://blog.csdn.net/z69183787/article/details/26709505">https://blog.csdn.net/z69183787/article/details/26709505</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>mongobd</tag>
      
      <tag>json</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mongoDB初探</title>
    <link href="/blog/post/uncategorized/68efd8d6/"/>
    <url>/blog/post/uncategorized/68efd8d6/</url>
    
    <content type="html"><![CDATA[<p>❀❀持续更新❀❀  </p><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p><img src="https://i.loli.net/2020/11/19/fZct4KnU12YIA7V.png" alt="image.png"><br>简单的说，mongoDB是一种非关系型的数据库(NoSQL)。  </p><blockquote><p>SQL，结构化查询语句<br>NoSQl = not only SQL  </p></blockquote><p>关系型数据库已经是老熟人了，经常被用来开发各种系统。非关系型数据库和它最显著的区别就是，去掉了数据之间的关联。回忆一下，在使用关系型数据库时，要考虑各种主键，外键，候选键，还要对表结构进行优化，考虑删除更新时的依赖，非常复杂。去掉数据关联自然让数据库结构变得简单，更加容易扩展，对大数据的性能直接起飞。<br>非关系型数据库种类繁多，例如键值存储数据库、列存储数据库、文档型数据库、图像数据库…<br>mongoDB就是一种文档型数据库 (待补)</p><h3 id="MongoDB-Shell"><a href="#MongoDB-Shell" class="headerlink" title="MongoDB Shell"></a>MongoDB Shell</h3><p><code>MongoDB shell</code>是可以通过命令行的方式与mongoDB进行交互。<br>安装完mongoDB之后，就可以在命令行中切换到安装目录下的<code>bin</code>文件夹内，输入<code>mongo</code>即可进入<code>MongoDB shell</code>  </p><pre><code class="hljs bash">~~\bin&gt;mongo</code></pre><p>当然，你也可以直接点击<code>bin</code>文件夹下的<code>mongo.exe</code>，效果相同。或者将文件目录配置到环境变量里，这样就可以在任意位置访问了。<br>一些简单的命令：  </p><pre><code class="hljs bash">db<span class="hljs-comment"># 查看当前数据库</span><span class="hljs-comment"># 默认返回test，因为test是默认数据库</span>show dbs<span class="hljs-comment"># 查看数据库列表</span>use &lt;数据库名称&gt;<span class="hljs-comment"># 切换数据库，数据库无需创建</span><span class="hljs-comment"># mongoDB会在第一次存储数据时创建数据库</span>db.dropDatabase()<span class="hljs-comment"># 删除当前数据库</span></code></pre><h3 id="图形化管理工具"><a href="#图形化管理工具" class="headerlink" title="图形化管理工具"></a>图形化管理工具</h3><ol><li><p><a href="http://www.navicat.com.cn/">Navicate 15</a><br>14天全功能试用<br>支持中文<br>很强大的数据库管理工具，支持非常多的数据库，还支持许多国内云存储服务。  </p></li><li><p><a href="https://robomongo.org/">Robo 3T</a><br>开源免费<br>不支持中文<br>简单好用  </p></li></ol><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://mongodb.net.cn/">https://mongodb.net.cn/</a></li><li><a href="https://www.mongodb.org.cn/">https://www.mongodb.org.cn/</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>database</tag>
      
      <tag>nosql</tag>
      
      <tag>mongodb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决弹出层的滚动页面bug</title>
    <link href="/blog/post/uncategorized/dd3c08c0/"/>
    <url>/blog/post/uncategorized/dd3c08c0/</url>
    
    <content type="html"><![CDATA[<p>❀❀有空更新❀❀  </p><p>我们常常会在body下设置一个全屏显示的元素作为弹出层的底层，或是通过相对body的绝对定位或是fixed，在上面实现提示信息和对话框等功能。<br>这个弹出层通常是需要阻止用户对内容的操作的，因为h5中一般情况下只会触发最上面元素的事件，所以大多数场景下都可以阻止内容层事件。<br>但是对于滚动事件，有一点需要注意。如果内容层的高度将body的高度撑高，导致body高度大于视口高度，此时在弹出层上进行滚动时，你就会发现内容层也跟着滚动了。<br>发生这种情况的原因很简单，作为弹出层，触发了滚动事件，并将该事件向父级传递了，也就是向body传递。 body滚动，内容层自然跟着滚动了。<br>既然是由于弹出层的事件传递造成的，阻止他就可以了，使用<code>event.stopPropagation()</code>就可以了。<br>除此之外，你也可以为body设置100%高度，并将overflow设为hidden，这样body本身就不会滚动了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>markdown学习笔记</title>
    <link href="/blog/post/uncategorized/d7bdf81a/"/>
    <url>/blog/post/uncategorized/d7bdf81a/</url>
    
    <content type="html"><![CDATA[<h3 id="插入代码"><a href="#插入代码" class="headerlink" title="插入代码"></a>插入代码</h3><p>markdown可以方便的实现代码引用  </p><ul><li><p>代码不分行  </p><pre><code class="hljs autohotkey">`code` \\ `是反引号</code></pre></li><li><p>多行代码  </p><pre><code class="hljs excel">```<span class="hljs-built_in">type</span><span class="hljs-built_in">code</span><span class="hljs-built_in">code</span><span class="hljs-built_in">code</span>```</code></pre><p>还可以支持语法高亮，例如  </p><pre><code class="hljs js"><span class="hljs-keyword">var</span> f1 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">param</span>) </span>&#123;    <span class="hljs-keyword">return</span> param&gt;<span class="hljs-number">0</span>;&#125;</code></pre></li><li><p>一些常用的语言  </p><ul><li><code>bash</code><br>例如<code>git</code>语句  </li><li><code>js</code>or<code>javascript</code><br>javascript代码  </li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git学习笔记</title>
    <link href="/blog/post/uncategorized/21db94ec/"/>
    <url>/blog/post/uncategorized/21db94ec/</url>
    
    <content type="html"><![CDATA[<h3 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h3><ul><li>在提交时输入多行信息  </li></ul><pre><code class="hljs bash">git commit -m <span class="hljs-string">&quot;第一行</span><span class="hljs-string">第二行</span><span class="hljs-string">第三行&quot;</span></code></pre><ul><li>修改刚刚最后一次提交的注释  </li></ul><pre><code class="hljs bash">git commit --amend</code></pre><p>更多内容可以参考<a href="https://www.jianshu.com/p/098d85a58bf1">https://www.jianshu.com/p/098d85a58bf1</a>  </p><h3 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h3><ul><li>撤销当前工作区的修改<br>未add到暂存区，则撤销回和版本库一样，add到暂存区后又做修改，则撤销回上一次add到暂存区后的状态  </li></ul><pre><code class="hljs bash"><span class="hljs-comment"># 撤销指定文件的修改</span>git checkout -- &lt;文件名&gt;<span class="hljs-comment"># 撤销所有修改</span>git checkout .</code></pre><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>git鼓励使用分支进行新功能的开发，而且因为git中分支通过指针实现，对分支的创建、删除、修改都十分方便快速。  </p><ul><li>创建分支  </li></ul><pre><code class="hljs bash">git branch &lt;分支名称&gt;<span class="hljs-comment"># 创建分支并切换到该分支  </span>git checkout -b &lt;分支名称&gt;git switch -c &lt;分支名称&gt;</code></pre><ul><li>重命名  </li></ul><pre><code class="hljs bash"><span class="hljs-comment"># 本地分支</span>git branch -m &lt;旧名称&gt; &lt;新名称&gt;<span class="hljs-comment"># 如果要同时重命名远端分支，还要执行下面的命令</span>git push origin &lt;新名称&gt;git push -d origin &lt;旧名称&gt;</code></pre><ul><li>查看分支  </li></ul><pre><code class="hljs bash"><span class="hljs-comment"># 查看本地分支</span>git branch<span class="hljs-comment"># 查看远程分支</span>git branch -r<span class="hljs-comment"># 查看所有分支</span>git branch -a</code></pre><ul><li>切换分支</li></ul><pre><code class="hljs bash">git checkout &lt;分支名称&gt;git switch &lt;分支名称&gt;</code></pre><ul><li>删除分支  </li></ul><pre><code class="hljs bash">git branch -d &lt;分支名称&gt;</code></pre><ul><li>合并分支</li></ul><pre><code class="hljs bash"><span class="hljs-comment"># 合并指定分支到当前分支</span>git merge &lt;分支名称&gt;</code></pre><p>git会尝试使用<code>Fast forward</code>方式进行合并。<br>当合并过程中会出现冲突时，git通过<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记不同分支内容，需要手动修改冲突，并重新提交(add&amp;commit)。<br>git默认使用<code>Fast forward</code>方式合并，删除分支后，是看不到分支信息的。<br>可以在合并的时候禁用<code>Fast forward</code>模式，此时，会生成一个新的commit，就可以从历史中看到分支信息了。  </p><pre><code class="hljs bash">git merge --no-ff -m <span class="hljs-string">&quot;commit信息&quot;</span> &lt;分支名称&gt;</code></pre><ul><li>选择特点commit进行合并  </li></ul><p>开发中存在某次提交内容为bug修改，想要将该提交复制到其他分支上可以使用<code>cheey-pick</code>  </p><pre><code class="hljs bash">git cheey-pick &lt;commit编号&gt;</code></pre><ul><li>远程操作  </li></ul><pre><code class="hljs bash"><span class="hljs-comment"># 从远程下载下所有变动，不会自动合并到本地</span>git fetch &lt;远程主机名&gt;<span class="hljs-comment"># 获取指定分支的变动</span>git fetch &lt;远程主机名&gt; &lt;远程分支名&gt;</code></pre><pre><code class="hljs bash"><span class="hljs-comment"># 从远程拉取变动，并与本地指定分支合并</span>git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;<span class="hljs-comment"># 如果是和当前分支合并可以简写为</span>git pull &lt;远程主机名&gt; &lt;远程分支名&gt;<span class="hljs-comment"># 也可以简写为</span>git pull</code></pre><h3 id="暂存工作区"><a href="#暂存工作区" class="headerlink" title="暂存工作区"></a>暂存工作区</h3><p>在开发过程中需要临时处理bug，但是当前工作尚未完成(尚未commit)，可以使用<code>stash</code>保存工作区。  </p><ul><li>保存  </li></ul><pre><code class="hljs bash">git stash</code></pre><ul><li>查看  </li></ul><pre><code class="hljs bash">git stash list</code></pre><ul><li>恢复</li></ul><pre><code class="hljs bash"><span class="hljs-comment"># 不会删除stash</span>git stash apply<span class="hljs-comment"># 恢复指定stash</span>git stash apply &lt;stash@&#123;编号&#125;&gt;</code></pre><pre><code class="hljs bash"><span class="hljs-comment"># 同时从stash list中删除</span>git stash pop</code></pre><ul><li>删除  </li></ul><pre><code class="hljs bash">git stash drop</code></pre><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><ul><li>查看标签  </li></ul><pre><code class="hljs bash">git tag<span class="hljs-comment"># 查看标签信息</span>git show &lt;tag名称&gt;</code></pre><ul><li>创建标签<br>创建和删除标签都是在本地操作，如果想要同步到远程可以查看<a href="#tag_origin">远程操作</a>部分。  </li></ul><pre><code class="hljs bash"><span class="hljs-comment"># 默认标签打在最新提交的commit上，即HEAD</span>git tag &lt;tag名称&gt;<span class="hljs-comment"># 达到指定的commit上</span>git tag &lt;tag名称&gt; &lt;commit id&gt;<span class="hljs-comment"># 创建带有说明的标签</span>git tag -a &lt;tag名称&gt; -m <span class="hljs-string">&quot;tag信息&quot;</span></code></pre><ul><li>删除标签</li></ul><pre><code class="hljs bash">git tag -d &lt;tag名称&gt;</code></pre><ul><li><span id="tag_origin">远程操作</span>  </li></ul><pre><code class="hljs bash"><span class="hljs-comment"># 推送一个标签</span>git push origin &lt;tag名称&gt;<span class="hljs-comment"># 一次性推送所有未推送的标签</span>git push origin --tags<span class="hljs-comment"># 从远程删除</span>git push origin :refs/tags/&lt;tag名称&gt;</code></pre><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><ul><li>以分支图方式查看日志  </li></ul><pre><code class="hljs bash">git <span class="hljs-built_in">log</span> --graph</code></pre><h3 id="gitignore文件"><a href="#gitignore文件" class="headerlink" title="gitignore文件"></a><code>gitignore</code>文件</h3><ul><li>创建<code>gitignore</code>文件  </li></ul><pre><code class="hljs bash">touch .gitignore</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>async，await和promise</title>
    <link href="/blog/post/uncategorized/6959550f/"/>
    <url>/blog/post/uncategorized/6959550f/</url>
    
    <content type="html"><![CDATA[<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://www.jianshu.com/p/b4fd76c61dc9">https://www.jianshu.com/p/b4fd76c61dc9</a>  </li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搞定MIME类型</title>
    <link href="/blog/post/uncategorized/8c2ab168/"/>
    <url>/blog/post/uncategorized/8c2ab168/</url>
    
    <content type="html"><![CDATA[<p>MIME()多用途互联网邮件扩展类型，设定某种扩展名文件用应用程序打开时应该使用何种方式。<br>当该扩展名文件被访问时，浏览器会自动指定应用程序打开。  </p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3>]]></content>
    
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>css中的overflow</title>
    <link href="/blog/post/uncategorized/c8b68711/"/>
    <url>/blog/post/uncategorized/c8b68711/</url>
    
    <content type="html"><![CDATA[<ul><li><code>visible</code>  </li></ul><p><strong>默认值</strong><br>表示溢出元素不进行修剪  </p><ul><li><p><code>hidden</code><br>表示修剪溢出内容，并且不可见  </p></li><li><p><code>scroll</code><br>修剪溢出内容的同时，浏览器会显示滚动条方便查看  </p></li><li><p><code>auto</code><br>如果内容被修剪，则浏览器会显示滚动条以便查看  </p></li><li><p><code>inherit</code><br>继承自父元素  </p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>html中的框架标签</title>
    <link href="/blog/post/uncategorized/c946372e/"/>
    <url>/blog/post/uncategorized/c946372e/</url>
    
    <content type="html"><![CDATA[<h3 id="lt-main-gt"><a href="#lt-main-gt" class="headerlink" title="&lt;main&gt;"></a><code>&lt;main&gt;</code></h3><p>用来标记指定文档的主要内容<br>文档中不允许出现多个main元素，并且main元素不得是artice、aside、footer、header、nav的后代  </p><h3 id="lt-figure-gt-和-lt-figcaption-gt"><a href="#lt-figure-gt-和-lt-figcaption-gt" class="headerlink" title="&lt;figure&gt;和&lt;figcaption&gt;"></a><code>&lt;figure&gt;</code>和<code>&lt;figcaption&gt;</code></h3><blockquote><p>figure可翻译成图片图形、图像 caption可翻译成标题  </p></blockquote><p><code>&lt;figure&gt;</code>可以用来描述一个区块，将区块与其相关信息封装在一起。这个区块通常是图片，你也可以封装代码诗歌等内容。它是一个将主体内容和附加信息封装在一起的语义容器。<br><code>&lt;figcaption&gt;</code>是<code>&lt;figure&gt;</code>中的可选子元素，它可以用来进行文本描述，通常用来放置标题（例如论文中图片上方的标题），也可以同时出现多个。举个例子：  </p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">figure</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;demo.png&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;实例图片&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">figcaption</span>&gt;</span>实例图片...<span class="hljs-tag">&lt;/<span class="hljs-name">figcaption</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">figure</span>&gt;</span></code></pre><h3 id="lt-picture-gt"><a href="#lt-picture-gt" class="headerlink" title="&lt;picture&gt;"></a><code>&lt;picture&gt;</code></h3><p><code>&lt;picture&gt;</code>是一个容器标签，它内部使用<code>&lt;source&gt;</code>和<code>&lt;img&gt;</code>，用来指定不同情况下加载的图片。<br>有时候，我们的图片需要根据不同的尺寸的屏幕和像素密度，呈现不同的显示效果。比如在电脑上，图片往往是横向显示的；而在手机上，图片往往是纵向显示的，并且大部分手机的是多倍像素屏幕，同样分辨率的图片在电脑上显示清楚，在手机上就变得模糊了。<br>为了解决这些问题，你就可以使用<code>&lt;source&gt;</code>搭配<code>mdeia</code>和<code>srcset</code>属性针对不同像素密度，不同屏幕尺寸指定加载不同的图片了。举个荔枝：  </p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">picture</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">media</span>=<span class="hljs-string">&quot;(max-width: 400px)&quot;</span> <span class="hljs-attr">srcset</span>=<span class="hljs-string">&quot;demo-vertical.png</span></span><span class="hljs-tag"><span class="hljs-string">                                               demo-vertical_2x.png 2x&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">media</span>=<span class="hljs-string">&quot;(min-width: 401px)&quot;</span> <span class="hljs-attr">srcset</span>=<span class="hljs-string">&quot;demo-horizontal.png</span></span><span class="hljs-tag"><span class="hljs-string">                                               demo-horizontal_2x.png 2x&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;demo.png&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;demo&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">picture</span>&gt;</span></code></pre><p>浏览器就会根据<code>&lt;source&gt;</code>先后顺序，选择合适的图片进行加载。当上面的<code>&lt;source&gt;</code>都无法匹配时或者浏览器不支持<code>&lt;picture&gt;</code>时，你可以使用<code>&lt;img&gt;</code>来指定默认情况下加载的图片。  </p>]]></content>
    
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mate标签的content属性</title>
    <link href="/blog/post/uncategorized/f1023455/"/>
    <url>/blog/post/uncategorized/f1023455/</url>
    
    <content type="html"><![CDATA[<p>经常可以在head中有这样的写法:  </p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">X-UA-Compatible</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=egde,chrome=1&quot;</span>&gt;</span></code></pre><h3 id="直接说结论"><a href="#直接说结论" class="headerlink" title="直接说结论"></a>直接说结论</h3><p>这个声明表示:<br>如果浏览器使用IE内核，将会渲染至该浏览器的最高版本。<br>如果客户端中存在<a href="">Chrome Frame</a>并且启用，将会使用chrome内核渲染。  </p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://www.cnblogs.com/menyiin/p/6527339.html">https://www.cnblogs.com/menyiin/p/6527339.html</a>  </li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于table标签的样式</title>
    <link href="/blog/post/uncategorized/6f0625d3/"/>
    <url>/blog/post/uncategorized/6f0625d3/</url>
    
    <content type="html"><![CDATA[<p>关于table标签有3个比较特殊的属性来控制样式，分别是<code>border</code>，<code>cellspacing</code>，<code>cellpadding</code>。注意它们都是标签的属性，虽然控制样式但是和css中的属性是不同的。  </p><ul><li><code>border</code><br><code>border</code>属性与css中的<code>border</code>不同。table中的<code>border</code>用来设置表格<strong>是否</strong>有边框：<br><code>border=&quot;0&quot;</code>时表格无边框<br><code>border=其他值</code>时表格有边框，当<code>border=大于1的值</code>时，table边框宽度等于设定值，而table中的单元格td的边框宽度仍然为1  </li></ul><blockquote><p>许多网站说<code>border=&quot;&quot;</code>时表格无边框，但我实际测试下来是有的，有点奇怪。  </p></blockquote><ul><li><p><code>cellspacing</code><br>css中不存在该属性，它用来设置单元格之间的距离。  </p></li><li><p><code>cellpadding</code><br>css中也不存在该属性，它用来设置单元格的内边距，该值默认为1。  </p></li></ul><h3 id="如何去除table的默认样式"><a href="#如何去除table的默认样式" class="headerlink" title="如何去除table的默认样式"></a>如何去除table的默认样式</h3><ol><li><p>可以在html中设置 <code>border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;</code>。  </p></li><li><p>也可以在css中设置  </p><pre><code class="hljs css"><span class="hljs-selector-tag">table</span> &#123;  <span class="hljs-attribute">border-collapse </span>: collapse;  <span class="hljs-attribute">border-spacing</span>: <span class="hljs-number">0</span>;&#125;// 相当于设置<span class="hljs-selector-tag">cellspacing</span><span class="hljs-selector-tag">table</span> <span class="hljs-selector-tag">td</span> &#123;  <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;&#125;// 相当于设置<span class="hljs-selector-tag">cellpadding</span></code></pre></li></ol><h3 id="关于table的css样式"><a href="#关于table的css样式" class="headerlink" title="关于table的css样式"></a>关于table的css样式</h3><p>在上面的css中有这样两个属性：  </p><ul><li><code>border-collapse</code>它有两个值:  </li></ul><ol><li>默认为<code>separate</code>，表示table和单元格td的相邻边框独立  </li><li><code>collapse</code>表示相邻边框进行合并  </li></ol><ul><li><code>border-spacing</code>它表示如果边框是独立的，边框在横向和纵向上的间距。它也可以设置两个值，分别作用在横向和纵向上。  </li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>css</tag>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js事件冒泡</title>
    <link href="/blog/post/uncategorized/63ee94ee/"/>
    <url>/blog/post/uncategorized/63ee94ee/</url>
    
    <content type="html"><![CDATA[<p>js具有事件冒泡机制，所谓事件冒泡机制就是js事件是从内向外冒泡的，子节点触发事件后会向父节点触发同名事件，直到dom根节点。<br>举个栗子:  </p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">  $(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><span class="javascript">    $(<span class="hljs-string">&#x27;.outer&#x27;</span>).on(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><span class="javascript">      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;我是最外层&#x27;</span>);</span>    &#125;);<span class="javascript">    $(<span class="hljs-string">&#x27;.center&#x27;</span>).on(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><span class="javascript">      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;我是中间层&#x27;</span>);</span>    &#125;);<span class="javascript">    $(<span class="hljs-string">&#x27;.enter&#x27;</span>).on(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><span class="javascript">      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;我是最里层&#x27;</span>);</span>    &#125;);  &#125;);<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">  <span class="hljs-selector-class">.outer</span> &#123;</span><span class="css">    <span class="hljs-selector-tag">background-color</span>: <span class="hljs-selector-id">#555</span>;</span>  &#125;<span class="css">  <span class="hljs-selector-class">.center</span> &#123;</span><span class="css">    <span class="hljs-selector-tag">background-color</span>: <span class="hljs-selector-id">#999</span>;</span>  &#125;<span class="css">  <span class="hljs-selector-class">.enter</span> &#123;</span><span class="css">    <span class="hljs-selector-tag">background-color</span>: <span class="hljs-selector-id">#eee</span>;</span>  &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;outer&quot;</span>&gt;</span>    我是最外层    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span>      我是中间层      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;enter&quot;</span>&gt;</span>        我是最里层      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><p>点击最里层，试一下效果:<br><img src="https://i.loli.net/2020/11/19/LEZWgpv5I7Odf4o.png" alt="效果1">  </p><h3 id="对于冒泡机制的处理"><a href="#对于冒泡机制的处理" class="headerlink" title="对于冒泡机制的处理"></a>对于冒泡机制的处理</h3><p>有时候这种冒泡机制是会影响到业务逻辑的，有下面3种方法进行处理。  </p><ul><li><p><code>event.stopPropagation();</code><br>阻止事件冒泡   </p></li><li><p><code>event.preventDefault();</code><br>阻止事件默认行为，如点击链接的跳转行为  </p></li><li><p><code>return false;</code><br>阻止冒泡机制和默认行为  </p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git中容易搞错的命令</title>
    <link href="/blog/post/uncategorized/1986879b/"/>
    <url>/blog/post/uncategorized/1986879b/</url>
    
    <content type="html"><![CDATA[<p><em>❀❀持续更新❀❀</em>  </p><h3 id="git-fetch-和-git-pull"><a href="#git-fetch-和-git-pull" class="headerlink" title="git fetch 和 git pull"></a><code>git fetch</code> 和 <code>git pull</code></h3><p>一句话总结  </p><ul><li><code>git fetch</code>是将远程主机的最新内容拉取到本地  </li><li><code>git pull</code>是将远程主机最新内容拉取到本地并自动合并，即<code>git pull = git fetch + git merge</code>，当然产生冲突时，需要手动解决冲突。</li></ul><h3 id="git-merge-和-git-rebase"><a href="#git-merge-和-git-rebase" class="headerlink" title="git merge 和 git rebase"></a><code>git merge</code> 和 <code>git rebase</code></h3><h3 id="其他学习git资源"><a href="#其他学习git资源" class="headerlink" title="其他学习git资源"></a>其他学习git资源</h3><ul><li><p><a href="https://www.liaoxuefeng.com/wiki/896043488029600">廖雪峰大大的git教程</a><br>这个无需多言，相信很多人都是从这里学习git的，比较基础全面。  </p></li><li><p><a href="https://learngitbranching.js.org/?locale=zh_CN">learngitbranching</a><br>一个非常棒的可视化在线git命令学习网站，每一个命令都有生动细致的讲解，还有小联系可供巩固知识，从头到尾浏览一遍，相信可以对git有更深的理解。  </p></li><li><p><a href="https://pan.baidu.com/s/1AOoqjeGb_RVhueR7BXxkbQ">git命令备忘表</a><br>百度网盘提取码<code>ztnh</code>  </p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js中的奇怪知识</title>
    <link href="/blog/post/uncategorized/3320875d/"/>
    <url>/blog/post/uncategorized/3320875d/</url>
    
    <content type="html"><![CDATA[<h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3><p>先看荔枝：  </p><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(a);<span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot;hello&quot;</span>;</code></pre><p>上面的运行结果会输出<code>undefined</code>，这是因为，js会先解析代码，并将所有变量的声明语句提升到代码头部执行，这就是变量提升。<br>下面的代码与上面相同：  </p><pre><code class="hljs js"><span class="hljs-keyword">var</span> a;<span class="hljs-built_in">console</span>.log(a);a = <span class="hljs-string">&quot;hello&quot;</span>;</code></pre><blockquote><p>js中函数也被视为一种值，函数的声明语句同样也会被提升到代码头部执行。  </p></blockquote><h3 id=""><a href="#" class="headerlink" title="!!"></a><code>!!</code></h3><p>!! 可以快速判断值是否为0、null、’’和undefined</p><h3 id="function前的运算符"><a href="#function前的运算符" class="headerlink" title="function前的运算符"></a>function前的运算符</h3><p>()可以让函数声明变成表达式从而达到立即执行的目的，一元运算符同样可以。<br>下面的方法都可以达到同样的目的，返回值略有差异  </p><pre><code class="hljs js">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;IIFE&#x27;</span>)&#125;)()<span class="hljs-comment">// return undefined</span>+<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;IIFE&#x27;</span>)&#125;()<span class="hljs-comment">// return NaN</span>-<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;IIFE&#x27;</span>)&#125;()<span class="hljs-comment">// return NaN</span>~<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;IIFE&#x27;</span>)&#125;()<span class="hljs-comment">// return -1</span>!<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;IIFE&#x27;</span>)&#125;()<span class="hljs-comment">// return true</span></code></pre><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><p>js允许语句或代码块前有标签，用于定位，跳转到程序的指定位置，与break和continue配合使用。<br>用法:  </p><pre><code class="hljs js">&lt;label name&gt;:    语句/代码块</code></pre><p>荔枝：  </p><pre><code class="hljs js">top:    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++) &#123;            <span class="hljs-keyword">if</span>(i === <span class="hljs-number">2</span> &amp;&amp; j === <span class="hljs-number">2</span>)                <span class="hljs-keyword">break</span> top;            <span class="hljs-built_in">console</span>.log(i, j);        &#125;    &#125;</code></pre><p>当满足if条件时，break就会跳出双循环。  </p><h3 id="null与undefined"><a href="#null与undefined" class="headerlink" title="null与undefined"></a>null与undefined</h3><p>null与undefined在进行布尔运算时都表示为false，所以<code>null == undefined</code>会返回true，其实而在说不一样的。<br>null表示无、空，它是一个对象，在转换为Number时为0。而undefined表示未定义，它转换为Number时为NaN。<br>例如一个函数有一个参数，你可以传null，此时该参数有值，只不过这个值是空的；如果你什么值都不传，此时这个参数就是未定义的。  </p><h3 id="boolean的自动转换"><a href="#boolean的自动转换" class="headerlink" title="boolean的自动转换"></a>boolean的自动转换</h3><p>在需要布尔值时，以下6种值会转换为false，其他值会视为true：  </p><ol><li>undefined  </li><li>null  </li><li>false  </li><li>0  </li><li>NaN  </li><li>“”或’’（空串）<br>需要注意的是，[]和{}对于的布尔值是true并不是false。  </li></ol><h3 id="没有整数"><a href="#没有整数" class="headerlink" title="没有整数"></a>没有整数</h3><p>js中其实所有数字都是以64位浮点数形式存储，因此你会发现1和1.0是相同的：  </p><pre><code class="hljs js"><span class="hljs-number">1</span> === <span class="hljs-number">1.0</span> <span class="hljs-comment">// true</span></code></pre><p>需要注意的是，由于浮点数并不是精确值，涉及小数比较时需要特别小心。<br>有些运算只有整数，此时js会将64位浮点数转换为32位整数。  </p><h3 id="数值范围"><a href="#数值范围" class="headerlink" title="数值范围"></a>数值范围</h3><p>js中一个数大于等于2的1024次方，会发生正向溢出，即返回Infinity。<br>如果一个数小于等于2的-1075次方，会发生负向溢出，即返回0。<br>同时Number对象提供MAX_VALUE和MIN_VALUE属性表示具体的最大值和最小值。<br>js中数值可使用科学计数法，例如：</p><pre><code class="hljs js"><span class="hljs-number">123e3</span> <span class="hljs-comment">// 123000</span><span class="hljs-number">123E3</span> <span class="hljs-comment">// 123000</span></code></pre><blockquote><p>如果一个数，小数点前数字位数大于21或者小数点后零多于5个，会自动使用科学计算法。  </p></blockquote><h3 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h3><p>js支持4种进制：  </p><ol><li>十进制 没有前导0  </li><li>二进制 有前缀0b或0B  </li><li>八进制 有前缀0o或0O（或者0，该方法浏览器兼容，但是已在ES6中废除）  </li><li>十六进制 有前缀0x或0X  </li></ol><h3 id="0和-0"><a href="#0和-0" class="headerlink" title="+0和-0"></a>+0和-0</h3><p>+0和-0在几乎所有的场合都相同，除了它们作为分母时，荔枝：  </p><pre><code class="hljs js">+<span class="hljs-number">0</span> === -<span class="hljs-number">0</span> <span class="hljs-comment">//true</span><span class="hljs-number">1</span> / +<span class="hljs-number">0</span> === <span class="hljs-number">1</span> /-<span class="hljs-number">0</span> <span class="hljs-comment">// false</span></code></pre><h3 id="NaN和Infinity"><a href="#NaN和Infinity" class="headerlink" title="NaN和Infinity"></a>NaN和Infinity</h3><p>NaN表示非数字，即not a number，它依旧是Number类型。NaN是不等于<strong>任何值</strong>，举个荔枝：  </p><pre><code class="hljs js"><span class="hljs-literal">NaN</span> === <span class="hljs-literal">NaN</span> <span class="hljs-comment">// false</span></code></pre><p>比较特殊的是<code>0 / 0</code>会得到NaN。<br>Infinity表示无穷，正值太大或负值太小，一些奇怪的计算结果：  </p><pre><code class="hljs js"><span class="hljs-number">0</span> * <span class="hljs-literal">Infinity</span> <span class="hljs-comment">// NaN</span><span class="hljs-number">0</span> / <span class="hljs-literal">Infinity</span> <span class="hljs-comment">// 0</span><span class="hljs-literal">Infinity</span> / <span class="hljs-number">0</span> <span class="hljs-comment">// Infinity</span><span class="hljs-literal">Infinity</span> - <span class="hljs-literal">Infinity</span> <span class="hljs-comment">// NaN</span><span class="hljs-literal">Infinity</span> / <span class="hljs-literal">Infinity</span> <span class="hljs-comment">// NaN</span></code></pre><blockquote><p>null在与Infinity进行计算时，会转换为0；undefined在与Infinity计算时，都返回NaN。  </p></blockquote><h3 id="with语句"><a href="#with语句" class="headerlink" title="with语句"></a>with语句</h3><p>with的作用是在操作一个对象的多个属性时，可以书写方便：  </p><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj = &#123;    p1: <span class="hljs-number">1</span>,    p2: <span class="hljs-number">2</span>&#125;;<span class="hljs-keyword">with</span> (obj) &#123;    p1 = <span class="hljs-number">4</span>;    p2 = <span class="hljs-number">5</span>;&#125;</code></pre><h3 id="delete语句"><a href="#delete语句" class="headerlink" title="delete语句"></a>delete语句</h3><p>delete可以删除对象自身的属性，删除成功会返回true。<br>delete也可以删除数组成员，形成空位，但是不影响length属性。  </p><h3 id="一句话"><a href="#一句话" class="headerlink" title="一句话"></a>一句话</h3><ul><li>switch语句后的表达式与case后的内容进行比较时采用<code>===</code></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>eval和JSON.parse</title>
    <link href="/blog/post/uncategorized/de88c4c0/"/>
    <url>/blog/post/uncategorized/de88c4c0/</url>
    
    <content type="html"><![CDATA[<h3 id="JSON-parse和eval"><a href="#JSON-parse和eval" class="headerlink" title="JSON.parse和eval"></a>JSON.parse和eval</h3><p>JSON.parse和eval都可以将字符串解析成对象，有什么区别？</p><h3 id="JSON-parse"><a href="#JSON-parse" class="headerlink" title="JSON.parse"></a>JSON.parse</h3><p><code>JSON.parse()</code>对于需要解析的字符串要求比较严格：  </p><ul><li>属性名称必须使用双引号包裹  </li><li>最后一个属性后不可以有逗号  </li><li>对于数字不可以有前导0，小数点后至少有一个数字  </li><li>只有有限字符串可以被转义，不允许出现控制字符  </li><li>字符串必须使用双引号  </li></ul><p>除此之外，JSON.parse允许传入一个函数，用来过滤和转换  </p><h3 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h3><p><code>eval()</code>功能强大，可以对js字符串求值  </p><p>eval在解析的过程中甚至可以执行对应的js语句  </p><p>使用规则上，需要在字符串首尾加上括号，否则<code>&quot;&#123;&#125;&quot;</code>会被当成语句块处理<br>例如： <code>eval(&quot;(&quot;+jsonstr+&quot;)&quot;)</code></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>eval的宽容性要高于JSON.parse的，所以也可以解析不规范的JSON字符串，所以eval也不是很安全。<br>所以尽可能使用JSON.parse来解析字符串  </p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://www.cnblogs.com/lovesong/p/6036650.html">https://www.cnblogs.com/lovesong/p/6036650.html</a>  </li><li><a href="https://www.cnblogs.com/Liujunyan/p/4965924.html">https://www.cnblogs.com/Liujunyan/p/4965924.html</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>JSON</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>外联js脚本注意</title>
    <link href="/blog/post/uncategorized/c140a1d8/"/>
    <url>/blog/post/uncategorized/c140a1d8/</url>
    
    <content type="html"><![CDATA[<p>如图:<br><img src="https://image-static.segmentfault.com/215/179/2151798436-59da4801c6772_articlex" alt="图1"></p>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2020sublime注册码</title>
    <link href="/blog/post/uncategorized/447acdb4/"/>
    <url>/blog/post/uncategorized/447acdb4/</url>
    
    <content type="html"><![CDATA[<p>转载自<a href="http://www.haoscn.com/article6/6">http://www.haoscn.com/article6/6</a>，仅供学习使用，请支持正版。</p>]]></content>
    
    
    
    <tags>
      
      <tag>sublime</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js中的RegExp</title>
    <link href="/blog/post/uncategorized/918bc367/"/>
    <url>/blog/post/uncategorized/918bc367/</url>
    
    <content type="html"><![CDATA[<p>正则表达式，使用一个字符串描述、匹配某个规则的字符串搜索模式。它在字符串处理中有着非常强大的用处、这很多语言中都有对正则的支持。    </p><blockquote><p>英语 regluar expression，常简写为 regex、regexp、RE<br>js中的正则表达式通过regexp对象表示  </p></blockquote><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><ol><li>通过<code>//</code>  </li></ol><pre><code class="hljs js">/pattern/attributes</code></pre><ol start="2"><li>通过实例  </li></ol><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(pattern, attributes);</code></pre><p>attributes 为可选字符串，包括”g”,”i”,”m”，分别指代全局匹配、区分大小写和匹配多行，当然你也可以同时使用多个参数。  </p><h3 id="RegExp对象方法"><a href="#RegExp对象方法" class="headerlink" title="RegExp对象方法"></a>RegExp对象方法</h3><ol><li><p><code>test</code><br>功能：检索字符串是否匹配模式<br>成功返回：<code>true</code><br>失败返回：<code>false</code>   </p></li><li><p><code>exec</code><br>功能：检索字符串中指定值<br>成功返回：数组<br>失败返回：<code>null</code>   </p></li></ol><p>对于加了<code>g</code>标识符的正则表达式，<code>exec</code>和<code>test</code>每次调用会从上次捕获结尾索引开始接着匹配，直到找不到匹配项，你可以通过调用regexp对象的<code>lastIndex</code>来查看下次匹配的起始位置。举个荔枝：  </p><pre><code class="hljs js"><span class="hljs-keyword">var</span> re = <span class="hljs-regexp">/ac/g</span>,    str = <span class="hljs-string">&quot;gac uai bbacd poac&quot;</span>;<span class="hljs-comment">// re.lastIndex当前值为0</span>re.test(str);<span class="hljs-comment">// 返回true re.lastIndex当前值为3</span>re.test(str);<span class="hljs-comment">// 返回true re.lastIndex当前值为12</span>re.exec(str);<span class="hljs-comment">// 返回[&quot;ac&quot;, index: 16, input: &quot;gac uai bbacd poac&quot;, groups: undefined] re.lastIndex当前值为18</span>re.exec(str);<span class="hljs-comment">// 返回null re.lastIndex当前值为0</span></code></pre><h3 id="String支持正则表达式方法"><a href="#String支持正则表达式方法" class="headerlink" title="String支持正则表达式方法"></a>String支持正则表达式方法</h3><ol><li><p><code>search</code><br>功能：检索字符串中的子串<br>成功返回：第一个匹配的子串的起始位置<br>失败返回：<code>-1</code>  </p></li><li><p><code>match</code><br>功能：检索字符串中指定值<br>成功返回：匹配数组<br>失败返回：<code>null</code>  </p></li><li><p><code>replace</code><br>功能：使用字符串替换匹配子串<br>成功返回：新字符串  </p></li><li><p><code>split</code><br>功能：将字符串分割为字符串数组<br>成功返回：字符串数组  </p></li></ol><h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><ol><li>^和$<br>正则表达式中使用^和$分别表示匹配字符串的开头与结尾，举个荔枝  <pre><code class="hljs js"><span class="hljs-keyword">var</span> re = <span class="hljs-regexp">/^test$/</span>;re.test(<span class="hljs-string">&quot;otest&quot;</span>);re.test(<span class="hljs-string">&quot;testp&quot;</span>);<span class="hljs-comment">// 返回 false</span>re.test(<span class="hljs-string">&quot;test&quot;</span>);<span class="hljs-comment">// 返回 true</span></code></pre></li><li>括号<br>使用()可以获得括号内的匹配字符串，可以方便的获取有效信息，举个荔枝   <pre><code class="hljs js"><span class="hljs-keyword">var</span> re = <span class="hljs-regexp">/num_(\d+)/</span>;re.exec(<span class="hljs-string">&quot;name num_9909&quot;</span>);<span class="hljs-comment">// 返回 [&quot;num_9909&quot;, &quot;9909&quot;, ...]</span></code></pre></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>正则表达式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>section标签</title>
    <link href="/blog/post/uncategorized/f7c459da/"/>
    <url>/blog/post/uncategorized/f7c459da/</url>
    
    <content type="html"><![CDATA[<h3 id="lt-section-gt-lt-section-gt"><a href="#lt-section-gt-lt-section-gt" class="headerlink" title="&lt;section&gt;&lt;/section&gt;"></a><code>&lt;section&gt;&lt;/section&gt;</code></h3><p>sction标签 h5新增标签 表示一个内容区域<br>例如：章节、页脚、页眉  </p><p><em>对比 div &amp; article</em>  </p><ul><li><p>div 是无明确语义的，用作布局和样式标签，作为页面分区的容器<br>例如：用作大的布局框架  </p></li><li><p>article h5新增标签 作为特殊section，拥有更为明确的语义 表示独立的、完整的内容块<br>例如：一篇博文  </p></li></ul><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p><a href="https://blog.csdn.net/qq_41511151/article/details/98586981">https://blog.csdn.net/qq_41511151/article/details/98586981</a>  </p>]]></content>
    
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于邮箱收不到邮件的解决方法</title>
    <link href="/blog/post/uncategorized/19dfc0c3/"/>
    <url>/blog/post/uncategorized/19dfc0c3/</url>
    
    <content type="html"><![CDATA[<p><em>收不到邮件了╰（‵□′）╯</em>  </p><p>相信这个问题还是挺常见的，我经常遇到。一般注册网站啊，接收验证码啊，偶尔会遇到一直收不到邮件的情况，下面简单的总结下我的解决方法。当然，实在解决不了的情况，可以联系邮箱服务提供商客服，寻求帮助。  </p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><h4 id="检查邮件地址是否填写正确"><a href="#检查邮件地址是否填写正确" class="headerlink" title="检查邮件地址是否填写正确"></a>检查邮件地址是否填写正确</h4><p>这个发生概率很小，但有些时候一自信，搞了半天才发现地址填错了，这就很郁闷了，所以先排除掉这个问题，免得浪费时间。<br>个人建议如果是使用<a href="https://mail.qq.com/">QQ邮箱</a>之类的纯数字邮箱，可以设置一个英文邮箱地址，免费又方便，还可以尽量避免遗漏错误。  </p><h4 id="检查垃圾箱邮件"><a href="#检查垃圾箱邮件" class="headerlink" title="检查垃圾箱邮件"></a>检查垃圾箱邮件</h4><p>这种情况个人感觉是最常见的，所以检查一下垃圾箱吧。  </p><h4 id="检查邮件是否被系统拦截"><a href="#检查邮件是否被系统拦截" class="headerlink" title="检查邮件是否被系统拦截"></a>检查邮件是否被系统拦截</h4><p>有些情况，邮箱会自动拦截一些广告子类的邮件，或者你之前把某个联系人拉到了黑名单里，你的邮件可能就被自动拦截了。<br>这里以QQ邮箱为例，你可以在页面底部的自助查询中找到收信查询，看看最近是不是有邮件被拦截了。<br><img src="https://i.loli.net/2020/11/19/xWT3a7nksNCvfql.png" alt="自助查询"><br><img src="https://i.loli.net/2020/11/19/rcaQb6YxReDg7iw.png" alt="收信查询"></p><h4 id="检查数字账户是否被关闭"><a href="#检查数字账户是否被关闭" class="headerlink" title="检查数字账户是否被关闭"></a>检查数字账户是否被关闭</h4><p>今天遇到一个邮件死活收不到的情况，到设置里一看原理是数字账户被关闭了，服了。<br>如果你同时开始数字邮箱和英文邮箱，而英文邮箱可以收到邮件，数字邮箱收不到邮件可以检查一下。<br>还是以QQ邮箱为例，你可以在设置&gt;账户中找到它。<br><img src="https://i.loli.net/2020/11/19/NyVKr31QS9YTqIo.png" alt="设置"><br><img src="https://i.loli.net/2020/11/19/LniBsQVa9dlIMSp.png" alt="数字账户"></p><h3 id="一个自检方法"><a href="#一个自检方法" class="headerlink" title="一个自检方法"></a>一个自检方法</h3><p>用小号给自己的邮箱发一封邮件，试试又不要钱，你说是吧^o^/  </p>]]></content>
    
    
    
    <tags>
      
      <tag>email</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于虚荣停运</title>
    <link href="/blog/post/game/2a760663/"/>
    <url>/blog/post/game/2a760663/</url>
    
    <content type="html"><![CDATA[<h3 id="虚荣停运了"><a href="#虚荣停运了" class="headerlink" title="虚荣停运了"></a>虚荣停运了</h3><p><img src="https://i.loli.net/2020/11/19/BPoD2vJSXRlh7fV.png" alt="公告"><br>刚刚搞好博客，看了眼微信，我一下从椅子上跳了起来，猛喝了两大杯水，才勉强冷静下来。<br>👉 完整的<a href="https://mp.weixin.qq.com/s/34fL7SDz40mIT9X4ZgoEnA">停运公告</a>。<br>说实话，虚荣是我接触的第一款 Moba 游戏，没错大部人是 Dota 或者 LOL，我则是虚荣。<br>第一次玩的时候真的对这平板上的逆天画质感到惊艳，那时候只有 3v3，但是玩起来是真的有意思，也让我第一次感受到这种团队合作竞技游戏的魅力。当时还会看拳师的教学解说和比赛，这也是我第一次看游戏解说。<br>我接触虚荣的时候，已经有王者荣耀了，我也尝试过，但当时的王者荣耀还没什么牌面，画质一般，各方面都没什么竞争力，所以我还是更愿意和陌生人玩虚荣，当时喜欢玩塔卡和猴子，很跳，玩起来很欢乐，后来慢慢喜欢玩佩兔。没办法萌就是正义，又有谁可以拒绝这么万用的小可爱呢。<br>进入大学之后，一方面是因为没有平板了，一方面身边的人大多都玩王者了，所以我也慢慢 afk 了。<br>只是偶尔会下回来，瞧一瞧这些游戏里曾经一起战斗过的朋友们。</p><h3 id="雷姆"><a href="#雷姆" class="headerlink" title="雷姆"></a>雷姆</h3><p>早就料想到会停运，毕竟所有游戏都有自己的生命和发展阶段，但是没想到会这么块，挺可惜的。<br>虚荣的失败原因肯定是多方面的，单个人感觉主要是因为没有抓住机会，被竞争者超越了。就比如，这些年感觉游戏没什么长进，就加了 5v5 和轮盘。<br>希望未来可以玩到更好的移动端游戏吧。</p>]]></content>
    
    
    <categories>
      
      <category>game</category>
      
    </categories>
    
    
    <tags>
      
      <tag>虚荣</tag>
      
      <tag>moba</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>迁移后的第一篇</title>
    <link href="/blog/post/uncategorized/8385e82d/"/>
    <url>/blog/post/uncategorized/8385e82d/</url>
    
    <content type="html"><![CDATA[<h3 id="小声bb下"><a href="#小声bb下" class="headerlink" title="小声bb下"></a>小声bb下</h3><p>如果看到这段话，就证明博客可以正常运行啦，(●ˇ∀ˇ●)。  </p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>论文基本格式及内容</title>
    <link href="/blog/post/uncategorized/29176fe/"/>
    <url>/blog/post/uncategorized/29176fe/</url>
    
    <content type="html"><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>近期导师进行了一次指导，讲的主要内容是论文的基本组成部分和格式要求。大部分内容其实都有了解，但是实际写论文的过程中，还是有可能会忽视。整理下来，加深记忆也方便随时查看。本文根据当时记的笔记进行整理。</p><h3 id="特别注意"><a href="#特别注意" class="headerlink" title="特别注意"></a>特别注意</h3><ol><li>英文逗号后面加空格2.  变量要用斜体表示，当然类似PI的变量也可以不斜体 <del>PI不应该是常量吗，可能是当时写错了</del></li><li>每段首行要缩进2字符</li><li>论文采用 1、 1) ① a) 标识各级标题，且每级标题缩进2个字符</li><li>段落格式不好看可以采用两端对其</li><li>程序流程图需要有开始和结束</li></ol><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>包含以下四部分内容 适当<strong>加些修饰语</strong>  </p><ol><li>背景和问题</li><li>模型和方法</li><li>结果</li><li>结论 (好的方面和<del>不好的方面</del>)</li></ol><h3 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h3><p>3-5个关键词，从标题和摘要中选取  </p><h3 id="正文内容"><a href="#正文内容" class="headerlink" title="正文内容"></a>正文内容</h3><h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><ol><li>详细阐述背景，引出存在的问题，解决该问题的必要性和紧迫性。</li><li>给出论文的组织结构。</li></ol><h4 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h4><ol><li>针对该问题，哪些研究者做了哪些相关工作。取得了什么样的成果，存在什么样未解决的问题和带来了什么样的新问题。对此进行评价</li><li>你准备解决什么未解决的问题。</li><li>将你的文字贡献总结为2-3条。</li></ol><h4 id="问题分析和技术基础"><a href="#问题分析和技术基础" class="headerlink" title="问题分析和技术基础"></a>问题分析和技术基础</h4><ol><li>详细分析你要解决的问题，相比于相关工作部分更加具体(可以画图)。</li><li>你打算用什么方法解决，为何采用这些方法。</li></ol><h4 id="模型和方法"><a href="#模型和方法" class="headerlink" title="模型和方法"></a>模型和方法</h4><p>模型对应着框架，方法对应着算法  </p><ol><li>相关定义： 用表表示(缩写、变量等)，表格排序顺序：A-Za-z0-9，变量命名1-2个字符，一般情况下采用英文加数字的形式。</li><li>模型： 图表格式参见<a href="#jump">图、表、公式和算法格式</a>部分。</li><li>基于模型的算法或方法： 所有缩写请在引用中给出列表，算法格式参见<a href="#jump">图、表、公式和算法格式</a>部分。</li></ol><h4 id="实验分析"><a href="#实验分析" class="headerlink" title="实验分析"></a>实验分析</h4><ol><li>实验相关介绍<br>①实验的软、硬件环境。<br>②实验的参数： 通过表给出。<br>③实验数据集<br>④实验测试指标： 时间、收敛性、准确性、召回率、故障率等。<br>⑤实验对比方法介绍： 使用该对比方法的原因，为什么要使用这个方法，要有说服力。</li><li>实验结果分析<br>先自己方法和自身比较，再将自己方法和他人的方法比较，需要对每个指标做实验。<br>什么样的条件下最优</li></ol><h4 id="总结与展望"><a href="#总结与展望" class="headerlink" title="总结与展望"></a>总结与展望</h4><ol><li>总结本文工作的3-4个贡献，基本和之前一样，但是不要照抄，每个贡献4-5行。</li><li>给出存在的问题和可以改进的地方，给出2-3个。</li></ol><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>参考文献格式略，需要注意以下两点：  </p><ol><li>引用部位标识有两种方式: 引用<sup>[1]</sup> 或者Tom等人[2]。</li><li>不同类型的文献标识不同</li></ol><table><thead><tr><th>标识</th><th>来源</th></tr></thead><tbody><tr><td>[J]</td><td>期刊</td></tr><tr><td>[C]</td><td>会议</td></tr><tr><td>[M]</td><td>书籍</td></tr><tr><td>[D]</td><td>论文</td></tr></tbody></table><h3 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h3><p>别抄:)  </p><h3 id="图、表、公式和算法格式"><a href="#图、表、公式和算法格式" class="headerlink" title="图、表、公式和算法格式"></a><span id="jump">图、表、公式和算法格式</span></h3><ol><li>都要居中</li><li>字号比正文要小一号</li><li>提示出现三次，具体如示例所示，需要对其中的名词进行解释。</li></ol><h4 id="图"><a href="#图" class="headerlink" title="图"></a>图</h4><p>如图1.1 XXXX图所示。<br><img src="https://i.loli.net/2020/11/19/HoZiygBrehcKY1a.png" alt="图1.1"></p><center>图1.1 XXXX图</center>图1.1中，这里进行下介绍。<h4 id="表"><a href="#表" class="headerlink" title="表"></a>表</h4><p>如表1.1 XXXX表所示。  </p><center>表1.1 XXXX表</center><p><img src="https://i.loli.net/2020/11/19/jKaZLc8h1ISn9Pr.png" alt="图1.1"><br>每个符号、每个字母都要进行解释。  </p><h4 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h4><p>如式(1.1)所示。<br>$$ P(A|B)=\frac{P(B|A)P(A)}{P(B)} $$<br>每个符号、每个字母都要进行解释。  </p><h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><p>三线表，包含名称、输入、输出、参数和返回值，输出参数和返回值一致。<br>如算法1所示。<br><img src="https://i.loli.net/2020/11/19/Qb8j1l6GPNZreo3.png" alt="算法1"><br>算法1是什么功能，包括主要功能复杂度的分析。  </p>]]></content>
    
    
    
    <tags>
      
      <tag>论文</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
